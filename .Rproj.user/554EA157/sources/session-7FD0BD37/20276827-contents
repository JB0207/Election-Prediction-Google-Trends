
library(pacman)
p_load(tidyverse,
ggtext,
glue,
UpSetR,
ggupset,
patchwork,
rvest,
RColorBrewer, pacman, V8)

options(scipen=999)





# 1 Define NFT collections ####
data_collections <- data.frame(
  collection_name = c("Chikn",
                     "PartyAnimals",
                     "ChadDoge",
                     "Peons",
                     "WolfiLand",
                     "AvaxApes",
                     "morfs",
                     "BeegRock"),
collection_address = c("0x8927985B358692815E18F2138964679DcA5d3b79",
                        "0x880Fe52C6bc4FFFfb92D6C03858C97807a900691",
                        "0x357928B721890Ed007142e45502A323827caF812",
                        "0x4c5A8B71330D751bf995472f3AB8CeB06a98dD47",
                        "0xBC3323468319CF1a2a9CA71A6f4034b7Cb5F8126",
                        "0x6d5087B3082f73D42a32D85e38BC95dcceDe39Bb",
                       "0x535693b04736a436bf2AA28Ac5C4b8F27f623ccb",
                       "0x9a27660A1b610D3e617cA9FC58a648360e58bB9d"),
n_tokens_total = c(10000,
           10047,
           3250,
           5000,
           1000,
           10000,
           100,
           176))



# data_collections <- data_collections %>% arrange(n_tokens_total) %>%
#   slice(1:3)




# 2 Scrape data ####
# Filter data collection
# data_collections <- data_collections %>% filter(collection_name=="Chikn")
# data_collections <- data_collections %>% arrange(collection_name)



unlink("data", recursive = TRUE, force = TRUE)
dir.create("data") # folder for datafiles
for(i in 1:nrow(data_collections)){
  print(i)

  
  # Replace total supply only for peons
  if(data_collections$collection_name[i]=="BeegRock"){
    # Modify JS code
    js_code <- read_lines("nft-owner-store.js")
    js_code[5] <- paste('var contractadress = \"', 
                        data_collections$collection_address[i], '\";', sep="")
    js_code[25] <- gsub("var", "totalSupply = 176 //var", js_code[25])
    write_lines(js_code, file = "nft-owner-store.js")
    
    # Run JS code
    shell("cd C:\\Users\\Paul\\Google Drive\\1-Research\\2022_NFTs\\ && node nft-owner-store.js")
    
    js_code[25] <- gsub("totalSupply = 176 //var", "var", js_code[25])
    write_lines(js_code, file = "nft-owner-store.js")
  }
  
  # Modify JS code
  js_code <- read_lines("nft-owner-store.js")
  js_code[5] <- paste('var contractadress = \"', 
                      data_collections$collection_address[i], '\";', sep="")
  write_lines(js_code, file = "nft-owner-store.js")
  
  shell("cd C:\\Users\\Paul\\Google Drive\\1-Research\\2022_NFTs\\ && node nft-owner-store.js")

}
  




# 3 Load datasets into list ####
#Filter: data_collections <- data_collections %>% filter(collection_name=="BeegRock"| collection_name=="morfs")

datasets <- list()
for(i in 1:nrow(data_collections)){
  cat(i)
  data_i <- readLines(paste("./data/", data_collections$collection_address[i], ".txt", sep=""))
  data_i <- as_tibble(data_i) %>%
    rename(address = value) %>%
    group_by(address) %>%
    summarize(n_tokens = n()) %>% # aggregate
    mutate(nft_name = data_collections$collection_name[i],
           nft_contract = data_collections$collection_address[i]) %>%
    mutate(rank_n_tokens = dense_rank(desc(n_tokens))) %>%
    arrange(desc(n_tokens)) %>%
    # rename(!!paste("rank_", data_collections$collection_name[i], sep="") := rank,
    #        !!paste("nft_contract_", data_collections$collection_name[i], sep="") := nft_contract,
    #        !!paste("nft_name_", data_collections$collection_name[i], sep="") := nft_name,
    #        !!paste("n_tokens_", data_collections$collection_name[i], sep="") := n) %>%
    mutate(n_tokens_total = data_collections$n_tokens_total[i])
  
  datasets[[i]] <- data_i
}
names(datasets) <- data_collections$collection_name




# 5 Create long format ####
data_long <- bind_rows(datasets, .id = "column_label") %>%
  select(-column_label)

# Check whether number of addresses is right (check on joepegs)
data_long %>% 
  group_by(nft_name) %>% 
  summarize(n_addresses = n())




# 6 Create wide format ####
data_wide <- data_long %>% 
  group_by(address) %>% 
  summarize(collections = paste(nft_name, collapse=",")) %>%
  mutate(collections = str_split(collections, ",")) %>%
  ungroup() %>%
  mutate(n_addresses_total = n()) %>%
  group_by(collections) %>%
  mutate(n_addresses_combinations = n(),
         n_addresses_combinations_perc = n_addresses_combinations/n_addresses_total*100) %>%
  arrange(desc(n_addresses_combinations_perc))

# Add variable containing collections as string
data_wide$collections_str <- sapply(data_wide$collections[!!lengths(data_wide$collections)], toString)
table(data_wide$collections_str)

# Add variable containing number of collections
data_wide <- data_wide %>%
  mutate(n_collections = lengths(collections))

# Summarize (potentially filter) out least common combinations
  # Summarize according to rare combinations
  data_wide <- data_wide %>%
    mutate(collections = ifelse(n_addresses_combinations_perc <3, list("Other combin."), collections))
  # Summarize according to number of combinations
  
  data_wide <- data_wide %>%
    ungroup() %>%
    mutate(n_combinations = lengths(data_wide$collections)) %>%
    mutate(collections = ifelse(n_combinations >= 3, list("Other combin."), collections))




# Graphs ####  

# OVERLAPP ####
# Figure 1: Address overlap ####
  # across different NFT projects


# example of list input (list of named vectors)
p <- data_wide %>%
  # distinct(title, year, length, .keep_all=TRUE) %>%
  ggplot(aes(x=collections)) +
  geom_bar() +
  geom_text(stat='count', aes(label=after_stat(paste(count, 
                                                     " (", round(count / sum(count) * 100,1), "%)", 
                                                     sep="")),
                              hjust = after_stat(ifelse(count < max(count), -0.1, 1.1)),
                              color = after_stat(ifelse(count < max(count), "black", "white"))), # Adjust text labels
            vjust=0.4,
            size = 3,
            angle = 90) +
  scale_x_upset(n_intersections = 55) +
  #scale_y_continuous(lim = c(0, 2050)) +
  scale_color_manual(values = c("black" = "black", "white" = "white"),
                     guide = 'none') +
  theme_light(base_size = 16) +
  labs(x= "Collection",
       y = "Number of addresses",
       title = "Address overlap across Avax NFT collections (Source: @iantouf)",
       # subtitle = "Address overlap across Avax NFT collections (Source: @iantouf)",
       # title = paste("Address overlap: ", 
       #               collection1," and ", 
       #               collection2, " NFTs", sep = ""), 
       caption = str_wrap(paste("Date: ",
                                Sys.Date(), "; Explanation: X-axis shows addresses categorized according to their holding certain NFTs or combinations thereof (the latter depicted by connected dots); Y-axis shows number of addresses falling into those categories; Addresses that hold rare NFT combinations are summarized in the category 'Other combin.'. Beware: Addresses can not be equated with persons/holders. The overlap of holders is underestimated here.",
                                sep=""), width = 100)) +
    theme(plot.margin = margin(#t = 1,  # Top margin
                               #r = 1,  # Right margin
                               #b = 3,  # Bottom margin
                               l = 1,  # Left margin
                               unit = "cm"),
          plot.title = element_text(size = 16),
          axis.text.y = element_text(size=12),
          plot.caption = element_text(hjust = 0))
p
  ggsave(plot = p,
         filename = "plot_overlap.jpg", # e.g. change to pdf
         width = 8,
         height = 5,
         device = "jpg", # e.g. change to pdf
         dpi = 100)


  
  
# Figure 1.B: Overlap/large categories ####
  # But only take large categories in terms of percentage overlap!
  # Aim show communities with the largest address overlap
  # See filter possibility above
  
  
# Figure 1 C: Heatmap ####
  
# Create variable that contains all 2-by-2 combinations
    data_wide$combi <- list(NULL)
    for(i in 1:length(data_wide$collections)){
      x <- data_wide$collections[[i]]
      if(length(x)<=1){
      x <- paste(x, x, sep="-")
      }else{
        x <- combn(x,2) # All combinations
        x <- paste(x[1,], x[2,], sep="-")
      }

      data_wide$combi[[i]] <- x
      
    }
    
    data_plot <- data_wide %>%
      ungroup() %>%
      select(address, combi)%>%
      unnest(combi) %>%
      group_by(combi) %>%
      summarize(n = n()) %>%
      separate(col = combi,
               into = c("x", "y"),
               sep = "-")
      
    data_plot2 <- data_plot %>%
      dplyr::rename("y" = "x", 
             "x" = "y")
    data_plot <- bind_rows(data_plot, data_plot2) %>%
      distinct()
      
    ggplot(data_plot , aes(x = x, y = y, fill = n))+
      geom_tile(color = "white",
                lwd = 1.5,
                linetype = 1) +
      geom_text(aes(label = n), color = "white", size = 4) +
      scale_fill_gradient(low = "red", high = "darkgreen") +
      coord_fixed()+
      guides(fill = guide_colourbar(barwidth = 0.5,
                                    barheight = 20)) + 
      theme_classic()  +
      labs(x= "Collection",
           y = "Collection",
           title = "Address overlap across Avax NFT collections\nSource: @iantouf",
           caption = str_wrap(paste("Date: ",
                                    Sys.Date(), "; Explanation: Diagonal tiles show # of addresses that only possess an NFT of the respective collection; Off-diagnoal tiles show # of adresses that hold a combination of the respective collections; Important: Addresses may be counted several times if they hold more than two collections, i.e., columns/rows do not sum up to number of holding addresses; Beware: Addresses can not be equated with persons/holders. The overlap of holders is underestimated here.",
                                    sep=""), width = 60)) +
      theme(plot.margin = margin(#t = 1,  # Top margin
        l = 1,  # Left margin
        unit = "cm"),
        plot.title = element_text(size = 16),
        #xis.text.y = element_text(size=12),
        plot.caption = element_text(hjust = 0),
        axis.text.x = element_text(angle=30, hjust=1),
        axis.text.y = element_text(angle=30, hjust=1))
      

      
  # Convert to matrix
    # https://stackoverflow.com/questions/65856117/ggplot2-how-to-add-total-to-a-heatmap
    # Numbers don't add up really, the sum of addresses is too big!
    # Problem some addresse might turn up several times, because the span cateogries,
    # e.g., they hold Ape + chikn + peon hence turn up several times
    heatmap <- pivot_wider(data_plot, # Convert to matrix form
                             names_from = y, 
                             values_from = n) %>%
      janitor::adorn_totals("row") %>%
      janitor::adorn_totals("col") %>%
      dplyr::rename(Gene = x) %>%
      pivot_longer(-Gene, names_to = "Sample", values_to = "Abundance")


# Heatmap with totals
    ggplot(mapping = aes(x = Sample, y = Gene)) +
      geom_tile(data = filter(heatmap, Gene != "Total", Sample != "Total"), aes(fill = Abundance)) +
      geom_point(data = filter(heatmap, Gene == "Total" | Sample == "Total"), aes(color = Abundance), size = 10, shape = 19) +
      geom_text(data = heatmap, aes(label = round(Abundance, 2)), size = 3) + 
      scale_color_gradient2(low = "red", mid = "white", high = "grey", midpoint = 0) +
      scale_fill_distiller(name = "Relative Abundance (%)", palette = "RdYlGn") +
      scale_x_discrete(limits = unique(heatmap$Sample), position = "top") +
      scale_y_discrete(limits = rev(unique(heatmap$Gene))) +
      theme_minimal() +
      theme(
        text = element_text(size = 12),
        axis.text.y = element_text(size = 11, colour = "black"),
        strip.text.y = element_text(angle = 0),
        legend.direction = "horizontal",
        legend.position = "bottom",
        panel.grid.major = element_blank()
      )
    
  
# CONCENTRATION ####  
  
 
# Figure 2: NFT concentration ####
  collection_name <- "Chikn"
  data_plot <- datasets[[collection_name]]
  interval <- 5
  data_plot$cut <- cut(data_plot %>% 
                               select(2) %>% 
                               pull(), 
                             breaks = seq(0,max(data_plot %>% 
                                                  select(2) %>% 
                                                  pull()),by=interval)
                             )
  data_plot <- data_plot %>%
    group_by(cut) %>%
    add_count() %>%
    ungroup()
  
p <-  ggplot(data_plot,aes(x = cut))+
    geom_histogram(stat= "count") +
    stat_count(aes(#y=..count..,
                   label=after_stat(paste(count, 
                                          " (", round(count / sum(count) * 100,1), "%)", 
                                          sep="")),
                   hjust = after_stat(ifelse(count < max(count), -0.1, 1.1)),
                   color = after_stat(ifelse(count < max(count), "black", "white"))),
               geom="text",
               vjust=0.3,
               size = 3,
               angle = 90) +
    scale_color_manual(values = c("black" = "black", "white" = "white"),
                       guide = 'none') +
    scale_y_continuous(breaks = seq(0, max(data_plot$n)+100, 100)) + 
    scale_x_discrete(drop = FALSE) +
  theme_light() +
    theme(axis.text.x = element_text(angle=60, hjust=1),
          plot.caption = element_text(hjust = 0)) +
    labs(x= paste("Number of tokens/NFTs (",collection_name,")", sep=""),
         y = "Number of addresses",
         title = paste("Distribution of ",collection_name," NFT tokens across addresses (Source: @iantouf)", sep=""),
         caption = str_wrap(paste("Date: ",
                                  Sys.Date(), "; Explanation: X-axis shows number of tokens categorized, e.g., (0,5] means between 0 and 5 tokens. Y-axis shows addresses holding that number of tokens, e.g., ~", max(data_plot$n)," addresses hold between 0 and ", interval, " tokens. Numbers next to bars show the absolute and relative number of addresses that hold the corresponding amount of tokens. Beware: Addresses cannot be equated with persons.",
                                  sep=""), width = 130))
  p
  ggsave(plot = p,
         filename = "plot_concentration.jpg", # e.g. change to pdf
         width = 8,
         height = 5,
         device = "jpg", # e.g. change to pdf
         dpi = 200)  

  
  


  

  
# Figure 3: NFT concentration - small multiples ####
  data_plot <- data_long %>%
    mutate(nft_name = paste(nft_name, " (N = ", n_tokens_total, ")", sep=""))
 
  
  p <-  ggplot(data_plot,aes(x = n_tokens))+
    geom_histogram(stat= "count")  +
    facet_wrap(~nft_name, scales="free") +
    stat_count(aes(#y=..count..,
      label=after_stat(paste(count, 
                             " (", round(count / sum(count) * 100,1), "%)", 
                             sep="")),
      hjust = after_stat(ifelse(count < max(count), -0.1, 1.1)),
      color = after_stat(ifelse(count < max(count), "black", "white"))),
      geom="text",
      vjust=0.3,
      size = 3,
      angle = 90) +
    scale_color_manual(values = c("black" = "black", "white" = "white"),
                       guide = 'none')
  
  p
  ggsave(plot = p,
         filename = "plot_concentration.jpg", # e.g. change to pdf
         width = 8,
         height = 5,
         device = "jpg", # e.g. change to pdf
         dpi = 200)  
  
  
  
  
  
  
# Discord size ####
  # across Avax NFT projects
  

# Diamond hands graph ####
  # across NFT projects
  - x-axis time held in weekdays
  - Number of addresses (normalized by number of NFTs)
  
# Sankey plot for ownership accross adresses
  

  